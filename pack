#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Std;

my $usage=<<'EOT';
Usage:

    pack template value [... value] > blob

        Takes one or more string values and converts them to a binary blob using the rules given by
        the template. The blob is written to stdout.

    pack -u template < blob > values
    unpack template < blob > values (symlinked to pack)

        Reads a binary blob and converts it to string values using the rules given by the template.
        The values are written to stdout, one per line.

 The template is a sequence of characters that give the order and type of values, some of which are:

    a  A string with arbitrary binary data, will be null padded.
    A  A text (ASCII) string, will be space padded.
    Z  A null-terminated (ASCIZ) string, will be null padded.
    c  A signed char (8-bit) value.
    C  An unsigned char (octet) value.
    s  A signed short (16-bit) value.
    S  An unsigned short value.
    l  A signed long (32-bit) value.
    L  An unsigned long value.
    q  A signed quad (64-bit) value.
    Q  An unsigned quad value.
    i  A signed integer value in native format.
    I  An unsigned integer value in native format.
    n  An unsigned short (16-bit) in "network" (big-endian) order.
    N  An unsigned long (32-bit) in "network" (big-endian) order.
    v  An unsigned short (16-bit) in "VAX" (little-endian) order.
    V  An unsigned long (32-bit) in "VAX" (little-endian) order.
    f  A single-precision float in native format.
    d  A double-precision float in native format.
    D  A float of long-double precision in native format.
    x  A null byte (a.k.a ASCII NUL, "\000", chr(0))

Each template character may be followed by a number which represents either the number of values to
be gobbled from the list, or the length of the singular item, depending on the character type.

This program simply exposes the perl pack and unpack functions in a manner suitable for shell
scripting. See "perldoc -f pack" and "man perlpacktut" for *much* more information.
EOT

our %opts;
getopts("u", \%opts) || die($usage);

if ($opts{u} || $0 =~ /^(.*\/)?unpack$/)
{
    @ARGV == 1 or die($usage);
    local $/;
    $SIG{__WARN__} = sub { my $s=$_[0]; $s =~ s/ in unpack .*/./; die "$s" };
    print "$_\n" for unpack($ARGV[0], <STDIN>);
} else
{
    @ARGV > 1 or die($usage);
    $SIG{__WARN__} = sub { my $s=$_[0]; $s =~ s/ in pack .*/./; die "$s" };
    print pack(shift @ARGV, @ARGV);
}
